/**
 * Generate static content file from Airtable
 *
 * Usage: node scripts/generate-content.js
 *
 * This pulls all content from the Airtable Site Content table
 * and generates a JavaScript module that can be imported by React components.
 */

const fs = require('fs');
const path = require('path');

const AIRTABLE_BASE_ID = 'appL8Sn87xUotm4jF';
const AIRTABLE_TABLE_ID = 'tblTZ0F89UMTO8PO0';
// API key from environment variable or .env file
const AIRTABLE_API_KEY = process.env.AIRTABLE_API_KEY || loadLocalEnv()?.AIRTABLE_API_KEY;

// Load API key from local .env file for development
function loadLocalEnv() {
  try {
    const envPath = path.join(__dirname, '..', '.env');
    if (fs.existsSync(envPath)) {
      const content = fs.readFileSync(envPath, 'utf-8');
      const match = content.match(/AIRTABLE_API_KEY=(.+)/);
      if (match) return { AIRTABLE_API_KEY: match[1].trim() };
    }
  } catch (e) {}
  return null;
}

const OUTPUT_FILE = path.join(__dirname, '..', 'src', 'content', 'siteContent.js');

async function fetchAllRecords() {
  let allRecords = [];
  let offset = null;

  do {
    const url = new URL(`https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/${AIRTABLE_TABLE_ID}`);
    url.searchParams.append('pageSize', '100');
    if (offset) {
      url.searchParams.append('offset', offset);
    }

    const response = await fetch(url.toString(), {
      headers: {
        'Authorization': `Bearer ${AIRTABLE_API_KEY}`
      }
    });

    if (!response.ok) {
      throw new Error(`Airtable API error: ${response.status} ${await response.text()}`);
    }

    const data = await response.json();
    allRecords = allRecords.concat(data.records);
    offset = data.offset;

    console.log(`Fetched ${allRecords.length} records...`);
  } while (offset);

  return allRecords;
}

function processRecords(records) {
  const content = {
    sections: {},
    byPage: {},
    timeline: [],
    stats: [],
  };

  // First pass: organize all content
  for (const record of records) {
    const fields = record.fields;
    const section = fields.Section || 'unknown';
    const fieldName = fields.Field || '';
    const value = fields.Content || '';
    const page = fields.Page || 'Home';
    const color = fields.Color || 'ink';
    const order = fields.Order || 0;
    const visible = fields.Visible !== false;
    const component = fields.Component || '';
    const link = fields.Link || '';

    // Skip invisible items
    if (!visible) continue;

    // Skip items without field names
    if (!fieldName) continue;

    // Initialize section if needed
    if (!content.sections[section]) {
      content.sections[section] = {};
    }

    // Store the content with metadata
    content.sections[section][fieldName] = {
      value,
      color,
      order,
      component,
      link,
      page
    };

    // Also organize by page
    if (!content.byPage[page]) {
      content.byPage[page] = {};
    }
    if (!content.byPage[page][section]) {
      content.byPage[page][section] = {};
    }
    content.byPage[page][section][fieldName] = {
      value,
      color,
      order,
      component,
      link
    };
  }

  // Build timeline array
  const timelineSection = content.sections.timeline || {};
  const years = new Set();

  for (const key of Object.keys(timelineSection)) {
    const match = key.match(/^(\d{4})_/);
    if (match) {
      years.add(match[1]);
    }
  }

  for (const year of years) {
    content.timeline.push({
      year,
      location: timelineSection[`${year}_location`]?.value || '',
      theme: timelineSection[`${year}_theme`]?.value || '',
      link: timelineSection[`${year}_link`]?.value || '',
      color: timelineSection[`${year}_year`]?.color || 'teal',
      order: timelineSection[`${year}_year`]?.order || 0
    });
  }

  // Sort timeline by order
  content.timeline.sort((a, b) => a.order - b.order);

  // Build stats array
  const statsSection = content.sections.stats || {};
  const statIds = new Set();

  for (const key of Object.keys(statsSection)) {
    const match = key.match(/^(.+)_value$/);
    if (match) {
      statIds.add(match[1]);
    }
  }

  for (const id of statIds) {
    content.stats.push({
      id,
      value: statsSection[`${id}_value`]?.value || '',
      label: statsSection[`${id}_label`]?.value || id,
      color: statsSection[`${id}_value`]?.color || 'teal',
      order: statsSection[`${id}_value`]?.order || 0
    });
  }

  // Sort stats by order
  content.stats.sort((a, b) => a.order - b.order);

  return content;
}

function generateJavaScript(content) {
  const timestamp = new Date().toISOString();

  return `/**
 * Site content generated from Airtable
 *
 * Generated: ${timestamp}
 *
 * DO NOT EDIT THIS FILE DIRECTLY.
 * To update content:
 * 1. Edit the "Site Content" table in Airtable
 * 2. Run: npm run generate-content
 * 3. Review changes and commit
 */

// All content organized by section
export const sections = ${JSON.stringify(content.sections, null, 2)};

// Content organized by page
export const byPage = ${JSON.stringify(content.byPage, null, 2)};

// Timeline data (sorted by order)
export const timeline = ${JSON.stringify(content.timeline, null, 2)};

// Stats data (sorted by order)
export const stats = ${JSON.stringify(content.stats, null, 2)};

// Helper function to get content value
export function getContent(section, field, defaultValue = '') {
  return sections[section]?.[field]?.value ?? defaultValue;
}

// Helper function to get content with metadata
export function getContentMeta(section, field) {
  return sections[section]?.[field] ?? null;
}

// Helper function to get all content for a section
export function getSection(sectionName) {
  return sections[sectionName] ?? {};
}

// Helper function to get content for a specific page
export function getPageContent(pageName) {
  return byPage[pageName] ?? {};
}

// Color class mapping
const colorClasses = {
  teal: { text: 'text-brand-teal', bg: 'bg-brand-teal', border: 'border-brand-teal' },
  cardinal: { text: 'text-brand-cardinal', bg: 'bg-brand-cardinal', border: 'border-brand-cardinal' },
  'green-dark': { text: 'text-brand-green-dark', bg: 'bg-brand-green-dark', border: 'border-brand-green-dark' },
  ink: { text: 'text-brand-ink', bg: 'bg-brand-ink', border: 'border-brand-ink' },
  cream: { text: 'text-brand-cream', bg: 'bg-brand-cream', border: 'border-brand-cream' },
  gold: { text: 'text-brand-gold', bg: 'bg-brand-gold', border: 'border-brand-gold' },
  white: { text: 'text-white', bg: 'bg-white', border: 'border-white' },
};

export function getColorClass(colorName, type = 'text') {
  return colorClasses[colorName]?.[type] ?? '';
}

// Generation metadata
export const metadata = {
  generatedAt: '${timestamp}',
  recordCount: ${Object.values(content.sections).reduce((sum, s) => sum + Object.keys(s).length, 0)},
  sections: ${JSON.stringify(Object.keys(content.sections))},
  pages: ${JSON.stringify(Object.keys(content.byPage))}
};

export default {
  sections,
  byPage,
  timeline,
  stats,
  getContent,
  getContentMeta,
  getSection,
  getPageContent,
  getColorClass,
  metadata
};
`;
}

async function main() {
  console.log('='.repeat(50));
  console.log('Generating site content from Airtable');
  console.log('='.repeat(50));

  try {
    // Fetch records
    console.log('\nFetching records from Airtable...');
    const records = await fetchAllRecords();
    console.log(`Total records fetched: ${records.length}`);

    // Process records
    console.log('\nProcessing records...');
    const content = processRecords(records);
    console.log(`Sections: ${Object.keys(content.sections).join(', ')}`);
    console.log(`Timeline items: ${content.timeline.length}`);
    console.log(`Stats: ${content.stats.length}`);

    // Generate JavaScript
    console.log('\nGenerating JavaScript...');
    const js = generateJavaScript(content);

    // Ensure output directory exists
    const outputDir = path.dirname(OUTPUT_FILE);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Write file
    fs.writeFileSync(OUTPUT_FILE, js, 'utf-8');
    console.log(`\nWritten to: ${OUTPUT_FILE}`);

    // Summary
    console.log('\n' + '='.repeat(50));
    console.log('Content generation complete!');
    console.log('='.repeat(50));
    console.log('\nNext steps:');
    console.log('1. Review the generated file');
    console.log('2. Run: npm run build');
    console.log('3. Test locally: npm run dev');
    console.log('4. Deploy: npm run deploy');

  } catch (error) {
    console.error('\nError:', error.message);
    process.exit(1);
  }
}

main();
