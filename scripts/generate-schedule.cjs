/**
 * Generate schedule data file from Airtable Schedule table
 *
 * Usage: node scripts/generate-schedule.cjs
 *
 * This pulls all sessions from the Airtable Schedule table
 * and generates a JavaScript module for React components.
 */

const fs = require('fs');
const path = require('path');

const AIRTABLE_BASE_ID = 'appL8Sn87xUotm4jF';
const AIRTABLE_TABLE_NAME = 'Schedule';

// Load API key from environment or .env file
function loadApiKey() {
  if (process.env.AIRTABLE_API_KEY) {
    return process.env.AIRTABLE_API_KEY;
  }
  const envPath = path.join(__dirname, '..', '.env');
  if (fs.existsSync(envPath)) {
    const content = fs.readFileSync(envPath, 'utf-8');
    let match = content.match(/AIRTABLE_API_KEY=(.+)/);
    if (!match) match = content.match(/VITE_AIRTABLE_KEY=(.+)/);
    if (match) return match[1].trim();
  }
  throw new Error('AIRTABLE_API_KEY not found in environment or .env file');
}

const API_KEY = loadApiKey();
const OUTPUT_FILE = path.join(__dirname, '..', 'src', 'content', 'scheduleData.js');

async function fetchAllRecords() {
  let allRecords = [];
  let offset = null;
  const baseUrl = `https://api.airtable.com/v0/${AIRTABLE_BASE_ID}/${encodeURIComponent(AIRTABLE_TABLE_NAME)}`;

  do {
    const url = new URL(baseUrl);
    url.searchParams.append('pageSize', '100');
    if (offset) {
      url.searchParams.append('offset', offset);
    }

    const response = await fetch(url.toString(), {
      headers: {
        'Authorization': `Bearer ${API_KEY}`
      }
    });

    if (!response.ok) {
      throw new Error(`Airtable API error: ${response.status} ${await response.text()}`);
    }

    const data = await response.json();
    allRecords = allRecords.concat(data.records);
    offset = data.offset;

    console.log(`Fetched ${allRecords.length} records...`);
  } while (offset);

  return allRecords;
}

function generateSessionId(record, index) {
  // Use existing session_id field if available, otherwise generate one
  if (record.fields.session_id) {
    return record.fields.session_id;
  }

  // Generate ID from day and order, or fallback to index
  const day = (record.fields.day || record.fields.Day || 'unknown').toLowerCase();
  const order = record.fields.order || record.fields.Order || index + 1;
  return `${day}-session-${order}`;
}

function processRecords(records) {
  const sessions = records.map((record, index) => {
    const fields = record.fields;

    // Map Airtable fields to our schema (handle various field name formats)
    return {
      id: generateSessionId(record, index),
      airtableId: record.id,
      title: fields['Session title'] || fields.title || fields.Title || 'Untitled Session',
      description: fields.description || fields.Description || '',
      day: fields.day || fields.Day || 'Monday',
      startTime: fields.start_time || fields['Start time'] || fields.startTime || '',
      endTime: fields.end_time || fields['End time'] || fields.endTime || '',
      type: (fields.type || fields.Type || 'session').toLowerCase(),
      track: fields.track || fields.Track || null,
      room: fields.room || fields.Room || '',
      speakers: fields.speakers || fields.Speakers || '',
      speakerOrgs: fields.speaker_orgs || fields['Speaker orgs'] || fields.speakerOrgs || '',
      isBookmarkable: fields.is_bookmarkable !== false && fields.Type !== 'break',
      order: fields.order || fields.Order || index + 1,
      visible: fields.visible !== false && fields.Visible !== false,
      color: fields.color || fields.Color || 'teal',
    };
  });

  // Filter out invisible sessions and sort by day then order
  const visibleSessions = sessions
    .filter(s => s.visible)
    .sort((a, b) => {
      // Monday first, then Tuesday
      const dayOrder = { 'monday': 0, 'tuesday': 1 };
      const dayA = dayOrder[a.day.toLowerCase()] ?? 2;
      const dayB = dayOrder[b.day.toLowerCase()] ?? 2;
      if (dayA !== dayB) return dayA - dayB;
      return a.order - b.order;
    });

  // Group by day
  const byDay = {
    monday: visibleSessions.filter(s => s.day.toLowerCase() === 'monday'),
    tuesday: visibleSessions.filter(s => s.day.toLowerCase() === 'tuesday'),
  };

  // Get unique types for filtering
  const types = [...new Set(visibleSessions.map(s => s.type))];

  // Get unique tracks for filtering
  const tracks = [...new Set(visibleSessions.map(s => s.track).filter(Boolean))];

  return {
    sessions: visibleSessions,
    byDay,
    types,
    tracks,
    totalCount: visibleSessions.length,
  };
}

function generateJavaScript(data) {
  const timestamp = new Date().toISOString();

  return `/**
 * Schedule data generated from Airtable
 *
 * Generated: ${timestamp}
 *
 * DO NOT EDIT THIS FILE DIRECTLY.
 * To update:
 * 1. Edit the "Schedule" table in Airtable
 * 2. Run: npm run generate-schedule
 * 3. Review changes and commit
 */

// All sessions (sorted by day, then order)
export const sessions = ${JSON.stringify(data.sessions, null, 2)};

// Sessions grouped by day
export const sessionsByDay = ${JSON.stringify(data.byDay, null, 2)};

// Available session types for filtering
export const sessionTypes = ${JSON.stringify(data.types, null, 2)};

// Available tracks for filtering
export const sessionTracks = ${JSON.stringify(data.tracks, null, 2)};

// Helper function to get a session by ID
export function getSessionById(id) {
  return sessions.find(s => s.id === id) || null;
}

// Helper function to get multiple sessions by IDs
export function getSessionsByIds(ids) {
  return ids.map(id => getSessionById(id)).filter(Boolean);
}

// Helper function to get bookmarkable sessions only
export function getBookmarkableSessions() {
  return sessions.filter(s => s.isBookmarkable);
}

// Type colors mapping
export const typeColors = {
  session: { bg: 'bg-brand-teal/5', text: 'text-brand-teal', border: 'border-brand-teal/20' },
  workshop: { bg: 'bg-brand-cardinal/5', text: 'text-brand-cardinal', border: 'border-brand-cardinal/20' },
  break: { bg: 'bg-brand-cream', text: 'text-brand-ink/60', border: 'border-brand-ink/10' },
  special: { bg: 'bg-brand-green-dark/5', text: 'text-brand-green-dark', border: 'border-brand-green-dark/20' },
  lightning: { bg: 'bg-brand-gold/10', text: 'text-brand-gold', border: 'border-brand-gold/20' },
};

// Generation metadata
export const metadata = {
  generatedAt: '${timestamp}',
  totalSessions: ${data.totalCount},
  mondaySessions: ${data.byDay.monday.length},
  tuesdaySessions: ${data.byDay.tuesday.length},
};

export default {
  sessions,
  sessionsByDay,
  sessionTypes,
  sessionTracks,
  getSessionById,
  getSessionsByIds,
  getBookmarkableSessions,
  typeColors,
  metadata
};
`;
}

async function main() {
  console.log('='.repeat(50));
  console.log('Generating schedule data from Airtable');
  console.log('='.repeat(50));

  try {
    // Fetch records
    console.log('\nFetching records from Airtable Schedule table...');
    const records = await fetchAllRecords();
    console.log(`Total records fetched: ${records.length}`);

    // Process records
    console.log('\nProcessing records...');
    const data = processRecords(records);
    console.log(`Visible sessions: ${data.totalCount}`);
    console.log(`Monday: ${data.byDay.monday.length} sessions`);
    console.log(`Tuesday: ${data.byDay.tuesday.length} sessions`);
    console.log(`Types: ${data.types.join(', ')}`);
    console.log(`Tracks: ${data.tracks.length > 0 ? data.tracks.join(', ') : '(none)'}`);

    // Generate JavaScript
    console.log('\nGenerating JavaScript...');
    const js = generateJavaScript(data);

    // Ensure output directory exists
    const outputDir = path.dirname(OUTPUT_FILE);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Write file
    fs.writeFileSync(OUTPUT_FILE, js, 'utf-8');
    console.log(`\nWritten to: ${OUTPUT_FILE}`);

    // Summary
    console.log('\n' + '='.repeat(50));
    console.log('Schedule generation complete!');
    console.log('='.repeat(50));
    console.log('\nNext steps:');
    console.log('1. Review the generated file');
    console.log('2. Run: npm run build');
    console.log('3. Test locally: npm run dev');

  } catch (error) {
    console.error('\nError:', error.message);
    process.exit(1);
  }
}

main();
